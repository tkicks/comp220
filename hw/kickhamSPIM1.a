# Assignment SPIM 1
# Tyler Kickham
# Purpose: TBD
# Input: Positive integers in range {1,..., 15} ending with negative
# Output: Integer ean, variance (s^2), mode, frequency graph
# -------------------------------------------------------------------------
            .data
intArray:   .word   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
freqArray:  .word   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
mean:       .word   0
variance:   .word   0
mode:       .word   0
inMessage:  .asciiz "Enter up to 20 positive ints (1-15).\nPress Enter to submit each int.\nEnter a negative to finish: "
meanText:   .asciiz "Mean: "
varText:    .asciiz "Variance (s^2): "
modeText:   .asciiz "Mode: "
freqText:   .asciiz "Frequency graph:\n"
endMessage: .asciiz "Program completed and all information displayed.\n"
endl:       .asciiz "\n"
# -------------------------------------------------------------------------
            .text
            .globl main

main:
    # prompt for ints
            li      $v0, 4
            la      $a0, inMessage              # put inMessage text
            syscall

            li      $t0, 0                      # input counter
            li      $t1, 0                      # array index
            j       inputs                      # go to receiving ints loop


# -----------------------------------------------------------
inputs:
    # loop that receives inputs and stores them in intArray
            beq     $t0, 15, setupMean

            li      $v0, 5                      # receive int input
            syscall

            blt     $v0, 0, setupMean           # break if input < 0

            sw      $v0, intArray($t1)          # store input in array

            add     $t1, $t1, 4                 # move down a space in memory

            add     $t0, $t0, 1                 # add one to counter
            j       inputs
# -----------------------------------------------------------

# -----------------------------------------------------------
setupMean:
    # set up temp registers to find the mean
            li      $t1, 0                      # array index
            li      $t2, 0                      # holds added value, then mean after all pluses
            move    $t4, $t0                    # preserve original count
            j       doMeanAdd

# -----------------------------------------------------------
doMeanAdd:
    # figure out added value of the inputs
    # $t3 holds the current number
            beq     $t4, $zero, doMeanDiv       # divide when counter gets back to zero

            lw      $t3, intArray($t1)          # load current value into $t3
            add     $t2, $t2, $t3               # add the value to the other values
            sub     $t4, $t4, 1                 # subtract one from the counter
            add     $t1, $t1, 4                 # move down to next spot in array

            j       doMeanAdd
# -----------------------------------------------------------

# -----------------------------------------------------------
doMeanDiv:
    # divide after all pluses to find the mean and display it
            li      $v0, 4                      #
            la      $a0, meanText               # display "Mean: "
            syscall                             #

            div     $t2, $t0                    # divide the sum by the counter (num items)
            mflo    $a0                         # move the mean into $a0

            li      $v0, 1                      # print the mean (at syscall)
            syscall

            move    $t2, $a0                    # store the mean in $t2
            
            li		$v0, 4
            la		$a0, endl					# print endline char
            syscall

            j       varDiv
# -----------------------------------------------------------

# -----------------------------------------------------------
varDiv:
    # set up the division for the variance
    # $t2 has mean value
            li      $t1, 0                      # reset array index to 0
            li      $t3, 0                      # reset value of array index to 0
            li      $t4, 0                      # reset item counter to 0
            li      $t6, 1                      # temp to hold 1
            li		$t7, 0						# stores subtraction^2
			li		$t8, 0						# stores sum of all sub^2

            sub     $t5, $t0, $t6               # sub 1 from counter store in $t5

            j       sumDiffs
# -----------------------------------------------------------

# -----------------------------------------------------------
sumDiffs:
	# working
	# finds the sum of the (subtraction of each input from mean)^2
	# $t5 has div to multiply by (next part)
	# registers same as varDiv above
			beq		$t4, $t0, varMult
			
			lw		$t6, intArray($t3)			# store current value in $t6
			sub		$t7, $t6, $t2				# store current value - mean in $t7
			mult	$t7, $t7					# square difference
			mflo	$t7							# store value of ^2 in $t7
			add		$t8, $t8, $t7				# add it to the current sum
			
			add		$t3, $t3, 4					# next array index
			add		$t4, $t4, 1					# add one to counter
			
			j		sumDiffs
# -----------------------------------------------------------

# -----------------------------------------------------------
varMult:
	# multiplies $t5 by the summation
	# $t5 has div to multiply by
	# $t8 has summation to multiply by
	# registers same as sumDiffs above	
			li		$v0, 4						#
			la		$a0, varText				# print varText to screen
			syscall								#
			
			li		$v0, 1						# print variance
			div		$t8, $t5					# divide by n-1 to find the variance
			mflo	$a0							# retrieve the variance
			syscall
			
			j		resetReg
# -----------------------------------------------------------

# -----------------------------------------------------------
resetReg:
    # reset the registers no longer in use to new uses
    # $t0 - counter, $t1 - offset(intArray)
            li      $t2, 0                      # hold offset for freqArray
            li      $t3, 0                      # temp counter to preserve $t0
            li      $t4, 0                      # hold value of intArray index
            li      $t5, 0                      # find the right spot of freqArray

            j       countEach
# -----------------------------------------------------------

# -----------------------------------------------------------
countEach:
    # store the count of each number in freqArray
            beq     $t3, $t0, terminator        # break when the frequencies are all counted

            lw      $t4, intArray($t1)          # hold value of current intArray

            beq     $t4, $t5, addOne
            add     $t5, 1
            beq     $t4, $t5, addTwo
            add     $t5, 1
            beq     $t4, $t5, addThree
            add     $t5, 1
            beq     $t4, $t5, addFour
            add     $t5, 1
            beq     $t4, $t5, addFive
            add     $t5, 1
            beq     $t4, $t5, addSix
            add     $t5, 1
            beq     $t4, $t5, addSeven
            add     $t5, 1
            beq     $t4, $t5, addEight
            add     $t5, 1
            beq     $t4, $t5, addNine
            add     $t5, 1
            beq     $t4, $t5, addTen
            add     $t5, 1
            beq     $t4, $t5, addElev
            add     $t5, 1
            beq     $t4, $t5, addTwel
            add     $t5, 1
            beq     $t4, $t5, addThirt
            add     $t5, 1
            beq     $t4, $t5, addFourt
            add     $t5, 1
            beq     $t4, $t5, addFift
# -----------------------------------------------------------

# -----------------------------------------------------------
# the next fifteen segments will all be the same, but will
# add one to different indexes in freqArray
# -----------------------------------------------------------
addOne:
            li      $t2, 0                      # freqArray offset is zero for 1
            lw      $t4, freqArray($t2)         # hold current freqArray index count
            add     $t4, $t4, 1                 # add one to the count
            sw      $t4, freqArray($t2)         # store counter in freqArray


# -----------------------------------------------------------
terminator:
    # tell user it's all over
            li      $v0, 4
            la      $a0, endl
            syscall

            li      $v0, 4
            la      $a0, endMessage
            syscall

    # halt
            li      $v0, 10
            syscall
# -----------------------------------------------------------
