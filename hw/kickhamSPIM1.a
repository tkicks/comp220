# Assignment SPIM 1
# Tyler Kickham
# Purpose: TBD
# Input: Positive integers in range {1,..., 15} ending with negative
# Output: Integer ean, variance (s^2), mode, frequency graph
# -------------------------------------------------------------------------
            .data
intArray:   .word   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
freqArray:  .word   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
mean:       .word   0
variance:   .word   0
mode:       .word   0
inMessage:  .asciiz "Enter up to 20 positive ints.\nPress Enter to submit each int.\nEnter a negative to finish: "
meanText:   .asciiz "Mean: "
varText:    .asciiz "Variance (s^2): "
modeText:   .asciiz "Mode: "
freqText:   .asciiz "Frequency graph:\n"
endMessage: .asciiz "Program completed and all information displayed.\n"
endl:       .asciiz "\n"
# -------------------------------------------------------------------------
            .text
            .globl main

main:
    # prompt for ints
            li      $v0, 4
            la      $a0, inMessage              # put inMessage text
            syscall

            li      $t0, 0                      # input counter
            li      $t1, 0                      # array index
            j       inputs                      # go to receiving ints loop


# -----------------------------------------------------------
inputs:
    # loop that receives inputs and stores them in intArray
            beq     $t0, 15, setupMean

            li      $v0, 5                      # receive int input
            syscall

            blt     $v0, 0, setupMean           # break if input < 0

            sw      $v0, intArray($t1)          # store input in array

            add     $t1, $t1, 4                 # move down a space in memory

            add     $t0, $t0, 1                 # add one to counter
            j       inputs
# -----------------------------------------------------------

# -----------------------------------------------------------
setupMean:
    # set up temp registers to find the mean
            li      $t1, 0                      # array index
            li      $t2, 0                      # holds added value, then mean after all additions
            move    $t4, $t0                    # preserve original count
            j       doMeanAdd

# -----------------------------------------------------------
doMeanAdd:
    # figure out added value of the inputs
    # $t3 holds the current number
            beq     $t4, $zero, doMeanDiv       # divide when counter gets back to zero

            lw      $t3, intArray($t1)          # load current value into $t3
            add     $t2, $t2, $t3               # add the value to the other values
            sub     $t4, $t4, 1                 # subtract one from the counter
            add     $t1, $t1, 4                 # move down to next spot in array

            j       doMeanAdd
# -----------------------------------------------------------

# -----------------------------------------------------------
doMeanDiv:
    # divide after all additions to find the mean and display it
            li      $v0, 4                      #
            la      $a0, meanText               # display "Mean: "
            syscall                             #

            div     $t2, $t0                    # divide the sum by the counter (num items)
            mflo    $a0                         # move the mean into $a0

            li      $v0, 1                      # print the mean (at syscall)
            syscall

            move    $t2, $a0                    # store the mean in $t2

            j       varDiv
# -----------------------------------------------------------

# -----------------------------------------------------------
varDiv:
    # do the division for the variance
    # $t2 has mean value
            li      $t1, 0                      # reset array index to 0
            li      $t3, 0                      # reset value of array index to 0
            li      $t4, 0                      # reset item counter to 0
            li      $t5, 0                      # will hold what to multiply by
            li      $t6, 1                      # temp to hold 1

            sub     $t5, $t0, 1                 # sub 1 from counter store in $t5
            div     $t6, $t5                    # div 1 by $t5
            mflo    $t5                         # store the quotient in $t5

            j       terminator  


# -----------------------------------------------------------

# -----------------------------------------------------------
terminator:
    # tell user it's all over
            li      $v0, 4
            la      $a0, endl
            syscall

            li      $v0, 4
            la      $a0, endMessage
            syscall

    # halt
            li      $v0, 10
            syscall
# -----------------------------------------------------------